diff --git a/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewManager.kt b/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewManager.kt
index c5845b7..0b360d3 100644
--- a/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewManager.kt
+++ b/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewManager.kt
@@ -41,7 +41,7 @@ class CameraViewManager : ViewGroupManager<CameraView>() {
       .put(CameraOutputOrientationChangedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onOutputOrientationChanged"))
       .put(CameraPreviewOrientationChangedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onPreviewOrientationChanged"))
       .put(AverageFpsChangedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onAverageFpsChanged"))
-      .build()
+        .build() as MutableMap<String, Any>?
 
   override fun getName(): String = TAG
 
diff --git a/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewManager.kt.bak_before_rn081_fix_v2 b/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewManager.kt.bak_before_rn081_fix_v2
new file mode 100644
index 0000000..c5845b7
--- /dev/null
+++ b/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewManager.kt.bak_before_rn081_fix_v2
@@ -0,0 +1,261 @@
+package com.mrousavy.camera.react
+
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.common.MapBuilder
+import com.facebook.react.uimanager.ThemedReactContext
+import com.facebook.react.uimanager.ViewGroupManager
+import com.facebook.react.uimanager.annotations.ReactProp
+import com.mrousavy.camera.core.types.CameraDeviceFormat
+import com.mrousavy.camera.core.types.CodeScannerOptions
+import com.mrousavy.camera.core.types.OutputOrientation
+import com.mrousavy.camera.core.types.PixelFormat
+import com.mrousavy.camera.core.types.PreviewViewType
+import com.mrousavy.camera.core.types.QualityBalance
+import com.mrousavy.camera.core.types.ResizeMode
+import com.mrousavy.camera.core.types.Torch
+import com.mrousavy.camera.core.types.VideoStabilizationMode
+
+@Suppress("unused")
+class CameraViewManager : ViewGroupManager<CameraView>() {
+  companion object {
+    const val TAG = "CameraView"
+  }
+  public override fun createViewInstance(context: ThemedReactContext): CameraView = CameraView(context)
+
+  override fun onAfterUpdateTransaction(view: CameraView) {
+    super.onAfterUpdateTransaction(view)
+    view.update()
+  }
+
+  override fun getExportedCustomDirectEventTypeConstants(): MutableMap<String, Any>? =
+    MapBuilder.builder<String, Any>()
+      .put(CameraViewReadyEvent.EVENT_NAME, MapBuilder.of("registrationName", "onViewReady"))
+      .put(CameraInitializedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onInitialized"))
+      .put(CameraStartedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onStarted"))
+      .put(CameraStoppedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onStopped"))
+      .put(CameraShutterEvent.EVENT_NAME, MapBuilder.of("registrationName", "onShutter"))
+      .put(CameraErrorEvent.EVENT_NAME, MapBuilder.of("registrationName", "onError"))
+      .put(CameraCodeScannedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onCodeScanned"))
+      .put(CameraPreviewStartedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onPreviewStarted"))
+      .put(CameraPreviewStoppedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onPreviewStopped"))
+      .put(CameraOutputOrientationChangedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onOutputOrientationChanged"))
+      .put(CameraPreviewOrientationChangedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onPreviewOrientationChanged"))
+      .put(AverageFpsChangedEvent.EVENT_NAME, MapBuilder.of("registrationName", "onAverageFpsChanged"))
+      .build()
+
+  override fun getName(): String = TAG
+
+  override fun onDropViewInstance(view: CameraView) {
+    view.destroy()
+    super.onDropViewInstance(view)
+  }
+
+  @ReactProp(name = "cameraId")
+  fun setCameraId(view: CameraView, cameraId: String) {
+    view.cameraId = cameraId
+  }
+
+  @ReactProp(name = "isMirrored")
+  fun setIsMirrored(view: CameraView, isMirrored: Boolean) {
+    view.isMirrored = isMirrored
+  }
+
+  @ReactProp(name = "preview", defaultBoolean = true)
+  fun setPreview(view: CameraView, preview: Boolean) {
+    view.preview = preview
+  }
+
+  @ReactProp(name = "photo")
+  fun setPhoto(view: CameraView, photo: Boolean) {
+    view.photo = photo
+  }
+
+  @ReactProp(name = "video")
+  fun setVideo(view: CameraView, video: Boolean) {
+    view.video = video
+  }
+
+  @ReactProp(name = "audio")
+  fun setAudio(view: CameraView, audio: Boolean) {
+    view.audio = audio
+  }
+
+  @ReactProp(name = "enableLocation")
+  fun setEnableLocation(view: CameraView, enableLocation: Boolean) {
+    view.enableLocation = enableLocation
+  }
+
+  @ReactProp(name = "enableFrameProcessor")
+  fun setEnableFrameProcessor(view: CameraView, enableFrameProcessor: Boolean) {
+    view.enableFrameProcessor = enableFrameProcessor
+  }
+
+  @ReactProp(name = "pixelFormat")
+  fun setPixelFormat(view: CameraView, pixelFormat: String?) {
+    if (pixelFormat != null) {
+      val newPixelFormat = PixelFormat.fromUnionValue(pixelFormat)
+      view.pixelFormat = newPixelFormat
+    } else {
+      view.pixelFormat = PixelFormat.YUV
+    }
+  }
+
+  @ReactProp(name = "enableDepthData")
+  fun setEnableDepthData(view: CameraView, enableDepthData: Boolean) {
+    view.enableDepthData = enableDepthData
+  }
+
+  @ReactProp(name = "enableZoomGesture")
+  fun setEnableZoomGesture(view: CameraView, enableZoomGesture: Boolean) {
+    view.enableZoomGesture = enableZoomGesture
+  }
+
+  @ReactProp(name = "videoStabilizationMode")
+  fun setVideoStabilizationMode(view: CameraView, videoStabilizationMode: String?) {
+    if (videoStabilizationMode != null) {
+      val newMode = VideoStabilizationMode.fromUnionValue(videoStabilizationMode)
+      view.videoStabilizationMode = newMode
+    } else {
+      view.videoStabilizationMode = null
+    }
+  }
+
+  @ReactProp(name = "enablePortraitEffectsMatteDelivery")
+  fun setEnablePortraitEffectsMatteDelivery(view: CameraView, enablePortraitEffectsMatteDelivery: Boolean) {
+    view.enablePortraitEffectsMatteDelivery = enablePortraitEffectsMatteDelivery
+  }
+
+  @ReactProp(name = "format")
+  fun setFormat(view: CameraView, format: ReadableMap?) {
+    if (format != null) {
+      val newFormat = CameraDeviceFormat.fromJSValue(format)
+      view.format = newFormat
+    } else {
+      view.format = null
+    }
+  }
+
+  @ReactProp(name = "resizeMode")
+  fun setResizeMode(view: CameraView, resizeMode: String?) {
+    if (resizeMode != null) {
+      val newMode = ResizeMode.fromUnionValue(resizeMode)
+      view.resizeMode = newMode
+    } else {
+      view.resizeMode = ResizeMode.COVER
+    }
+  }
+
+  @ReactProp(name = "androidPreviewViewType")
+  fun setAndroidPreviewViewType(view: CameraView, androidPreviewViewType: String?) {
+    if (androidPreviewViewType != null) {
+      val newMode = PreviewViewType.fromUnionValue(androidPreviewViewType)
+      view.androidPreviewViewType = newMode
+    } else {
+      view.androidPreviewViewType = PreviewViewType.SURFACE_VIEW
+    }
+  }
+
+  // TODO: Change when TurboModules release.
+  // We're treating -1 as "null" here, because when I make the fps parameter
+  // of type "Int?" the react bridge throws an error.
+  @ReactProp(name = "minFps", defaultInt = -1)
+  fun setMinFps(view: CameraView, minFps: Int) {
+    view.minFps = if (minFps > 0) minFps else null
+  }
+
+  // TODO: Change when TurboModules release.
+  // We're treating -1 as "null" here, because when I make the fps parameter
+  // of type "Int?" the react bridge throws an error.
+  @ReactProp(name = "maxFps", defaultInt = -1)
+  fun setMaxFps(view: CameraView, maxFps: Int) {
+    view.maxFps = if (maxFps > 0) maxFps else null
+  }
+
+  @ReactProp(name = "photoHdr")
+  fun setPhotoHdr(view: CameraView, photoHdr: Boolean) {
+    view.photoHdr = photoHdr
+  }
+
+  @ReactProp(name = "photoQualityBalance")
+  fun setPhotoQualityBalance(view: CameraView, photoQualityBalance: String?) {
+    if (photoQualityBalance != null) {
+      val newMode = QualityBalance.fromUnionValue(photoQualityBalance)
+      view.photoQualityBalance = newMode
+    } else {
+      view.photoQualityBalance = QualityBalance.BALANCED
+    }
+  }
+
+  @ReactProp(name = "videoHdr")
+  fun setVideoHdr(view: CameraView, videoHdr: Boolean) {
+    view.videoHdr = videoHdr
+  }
+
+  @ReactProp(name = "videoBitRateOverride", defaultDouble = -1.0)
+  fun setVideoBitRateOverride(view: CameraView, videoBitRateOverride: Double) {
+    if (videoBitRateOverride != -1.0) {
+      view.videoBitRateOverride = videoBitRateOverride
+    } else {
+      view.videoBitRateOverride = null
+    }
+  }
+
+  @ReactProp(name = "videoBitRateMultiplier", defaultDouble = -1.0)
+  fun setVideoBitRateMultiplier(view: CameraView, videoBitRateMultiplier: Double) {
+    if (videoBitRateMultiplier != -1.0) {
+      view.videoBitRateMultiplier = videoBitRateMultiplier
+    } else {
+      view.videoBitRateMultiplier = null
+    }
+  }
+
+  @ReactProp(name = "lowLightBoost")
+  fun setLowLightBoost(view: CameraView, lowLightBoost: Boolean) {
+    view.lowLightBoost = lowLightBoost
+  }
+
+  @ReactProp(name = "isActive")
+  fun setIsActive(view: CameraView, isActive: Boolean) {
+    view.isActive = isActive
+  }
+
+  @ReactProp(name = "torch")
+  fun setTorch(view: CameraView, torch: String?) {
+    if (torch != null) {
+      val newMode = Torch.fromUnionValue(torch)
+      view.torch = newMode
+    } else {
+      view.torch = Torch.OFF
+    }
+  }
+
+  @ReactProp(name = "zoom")
+  fun setZoom(view: CameraView, zoom: Double) {
+    view.zoom = zoom.toFloat()
+  }
+
+  @ReactProp(name = "exposure")
+  fun setExposure(view: CameraView, exposure: Double) {
+    view.exposure = exposure
+  }
+
+  @ReactProp(name = "outputOrientation")
+  fun setOrientation(view: CameraView, outputOrientation: String?) {
+    if (outputOrientation != null) {
+      val newMode = OutputOrientation.fromUnionValue(outputOrientation)
+      view.outputOrientation = newMode
+    } else {
+      view.outputOrientation = OutputOrientation.DEVICE
+    }
+  }
+
+  @ReactProp(name = "codeScannerOptions")
+  fun setCodeScanner(view: CameraView, codeScannerOptions: ReadableMap?) {
+    if (codeScannerOptions != null) {
+      val newCodeScannerOptions = CodeScannerOptions.fromJSValue(codeScannerOptions)
+      view.codeScannerOptions = newCodeScannerOptions
+    } else {
+      view.codeScannerOptions = null
+    }
+  }
+}
diff --git a/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewModule.kt b/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewModule.kt
index 7ae4209..059f677 100644
--- a/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewModule.kt
+++ b/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewModule.kt
@@ -189,7 +189,7 @@ class CameraViewModule(reactContext: ReactApplicationContext) : ReactContextBase
   }
 
   private fun canRequestPermission(permission: String): Boolean {
-    val activity = currentActivity as? PermissionAwareActivity
+    val activity = reactApplicationContext.currentActivity as? PermissionAwareActivity
     return activity?.shouldShowRequestPermissionRationale(permission) ?: false
   }
 
diff --git a/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewModule.kt.bak_before_rn081_fix_v2 b/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewModule.kt.bak_before_rn081_fix_v2
new file mode 100644
index 0000000..7ae4209
--- /dev/null
+++ b/node_modules/react-native-vision-camera/android/src/main/java/com/mrousavy/camera/react/CameraViewModule.kt.bak_before_rn081_fix_v2
@@ -0,0 +1,261 @@
+package com.mrousavy.camera.react
+
+import android.Manifest
+import android.content.pm.PackageManager
+import android.util.Log
+import androidx.core.content.ContextCompat
+import com.facebook.react.bridge.Callback
+import com.facebook.react.bridge.Promise
+import com.facebook.react.bridge.ReactApplicationContext
+import com.facebook.react.bridge.ReactContextBaseJavaModule
+import com.facebook.react.bridge.ReactMethod
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.module.annotations.ReactModule
+import com.facebook.react.modules.core.PermissionAwareActivity
+import com.facebook.react.modules.core.PermissionListener
+import com.facebook.react.uimanager.UIManagerHelper
+import com.facebook.react.uimanager.common.UIManagerType
+import com.mrousavy.camera.BuildConfig
+import com.mrousavy.camera.core.CameraError
+import com.mrousavy.camera.core.CameraQueues
+import com.mrousavy.camera.core.ViewNotFoundError
+import com.mrousavy.camera.core.types.PermissionStatus
+import com.mrousavy.camera.core.types.RecordVideoOptions
+import com.mrousavy.camera.core.types.TakeSnapshotOptions
+import com.mrousavy.camera.core.utils.runOnUiThread
+import com.mrousavy.camera.core.utils.runOnUiThreadAndWait
+import com.mrousavy.camera.frameprocessors.VisionCameraInstaller
+import com.mrousavy.camera.frameprocessors.VisionCameraProxy
+import com.mrousavy.camera.react.utils.makeErrorMap
+import com.mrousavy.camera.react.utils.withPromise
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.asCoroutineDispatcher
+import kotlinx.coroutines.cancel
+import kotlinx.coroutines.isActive
+import kotlinx.coroutines.launch
+
+@ReactModule(name = CameraViewModule.TAG)
+@Suppress("unused")
+class CameraViewModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
+  companion object {
+    const val TAG = "CameraView"
+    var sharedRequestCode = 10
+
+    init {
+      try {
+        // Load the native part of VisionCamera.
+        // Includes the OpenGL VideoPipeline, as well as Frame Processor JSI bindings
+        System.loadLibrary("VisionCamera")
+      } catch (e: UnsatisfiedLinkError) {
+        Log.e(VisionCameraProxy.TAG, "Failed to load VisionCamera C++ library!", e)
+        throw e
+      }
+    }
+  }
+
+  private val backgroundCoroutineScope = CoroutineScope(CameraQueues.cameraExecutor.asCoroutineDispatcher())
+
+  override fun invalidate() {
+    super.invalidate()
+    if (backgroundCoroutineScope.isActive) {
+      backgroundCoroutineScope.cancel("CameraViewModule has been destroyed.")
+    }
+  }
+
+  override fun getName(): String = TAG
+
+  private suspend fun findCameraView(viewId: Int): CameraView =
+    runOnUiThreadAndWait {
+      Log.d(TAG, "Finding view $viewId...")
+      val context = reactApplicationContext ?: throw Error("React Context was null!")
+
+      val uiManagerType = if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) UIManagerType.FABRIC else UIManagerType.DEFAULT
+      val uiManager = UIManagerHelper.getUIManager(context, uiManagerType) ?: throw Error("UIManager not found!")
+
+      val view = uiManager.resolveView(viewId) as? CameraView ?: throw ViewNotFoundError(viewId)
+      Log.d(TAG, "Found view $viewId!")
+      return@runOnUiThreadAndWait view
+    }
+
+  @ReactMethod(isBlockingSynchronousMethod = true)
+  fun installFrameProcessorBindings(): Boolean =
+    try {
+      val proxy = VisionCameraProxy(reactApplicationContext)
+      VisionCameraInstaller.install(proxy)
+      true
+    } catch (e: Error) {
+      Log.e(TAG, "Failed to install Frame Processor JSI Bindings!", e)
+      false
+    }
+
+  @ReactMethod
+  fun takePhoto(viewTag: Int, options: ReadableMap, promise: Promise) {
+    backgroundCoroutineScope.launch {
+      val view = findCameraView(viewTag)
+      withPromise(promise) {
+        view.takePhoto(options)
+      }
+    }
+  }
+
+  @ReactMethod
+  fun takeSnapshot(viewTag: Int, jsOptions: ReadableMap, promise: Promise) {
+    backgroundCoroutineScope.launch {
+      val view = findCameraView(viewTag)
+      runOnUiThread {
+        try {
+          val options = TakeSnapshotOptions.fromJSValue(reactApplicationContext, jsOptions)
+          val result = view.takeSnapshot(options)
+          promise.resolve(result)
+        } catch (e: Throwable) {
+          promise.reject(e)
+        }
+      }
+    }
+  }
+
+  // TODO: startRecording() cannot be awaited, because I can't have a Promise and a onRecordedCallback in the same function. Hopefully TurboModules allows that
+  @ReactMethod
+  fun startRecording(viewTag: Int, jsOptions: ReadableMap, onRecordCallback: Callback) {
+    backgroundCoroutineScope.launch {
+      val view = findCameraView(viewTag)
+      try {
+        val options = RecordVideoOptions.fromJSValue(reactApplicationContext, jsOptions)
+        view.startRecording(options, onRecordCallback)
+      } catch (error: CameraError) {
+        val map = makeErrorMap("${error.domain}/${error.id}", error.message, error)
+        onRecordCallback(null, map)
+      } catch (error: Throwable) {
+        val map =
+          makeErrorMap("capture/unknown", "An unknown error occurred while trying to start a video recording! ${error.message}", error)
+        onRecordCallback(null, map)
+      }
+    }
+  }
+
+  @ReactMethod
+  fun pauseRecording(viewTag: Int, promise: Promise) {
+    backgroundCoroutineScope.launch {
+      withPromise(promise) {
+        val view = findCameraView(viewTag)
+        view.pauseRecording()
+        return@withPromise null
+      }
+    }
+  }
+
+  @ReactMethod
+  fun resumeRecording(viewTag: Int, promise: Promise) {
+    backgroundCoroutineScope.launch {
+      val view = findCameraView(viewTag)
+      withPromise(promise) {
+        view.resumeRecording()
+        return@withPromise null
+      }
+    }
+  }
+
+  @ReactMethod
+  fun stopRecording(viewTag: Int, promise: Promise) {
+    backgroundCoroutineScope.launch {
+      val view = findCameraView(viewTag)
+      withPromise(promise) {
+        view.stopRecording()
+        return@withPromise null
+      }
+    }
+  }
+
+  @ReactMethod
+  fun cancelRecording(viewTag: Int, promise: Promise) {
+    backgroundCoroutineScope.launch {
+      val view = findCameraView(viewTag)
+      withPromise(promise) {
+        view.cancelRecording()
+        return@withPromise null
+      }
+    }
+  }
+
+  @ReactMethod
+  fun focus(viewTag: Int, point: ReadableMap, promise: Promise) {
+    backgroundCoroutineScope.launch {
+      val view = findCameraView(viewTag)
+      withPromise(promise) {
+        view.focus(point)
+        return@withPromise null
+      }
+    }
+  }
+
+  private fun canRequestPermission(permission: String): Boolean {
+    val activity = currentActivity as? PermissionAwareActivity
+    return activity?.shouldShowRequestPermissionRationale(permission) ?: false
+  }
+
+  private fun getPermission(permission: String): PermissionStatus {
+    val status = ContextCompat.checkSelfPermission(reactApplicationContext, permission)
+    var parsed = PermissionStatus.fromPermissionStatus(status)
+    if (parsed == PermissionStatus.DENIED && canRequestPermission(permission)) {
+      parsed = PermissionStatus.NOT_DETERMINED
+    }
+    return parsed
+  }
+
+  @ReactMethod(isBlockingSynchronousMethod = true)
+  fun getCameraPermissionStatus(): String {
+    val status = getPermission(Manifest.permission.CAMERA)
+    return status.unionValue
+  }
+
+  @ReactMethod(isBlockingSynchronousMethod = true)
+  fun getMicrophonePermissionStatus(): String {
+    val status = getPermission(Manifest.permission.RECORD_AUDIO)
+    return status.unionValue
+  }
+
+  @ReactMethod(isBlockingSynchronousMethod = true)
+  fun getLocationPermissionStatus(): String {
+    val fineStatus = getPermission(Manifest.permission.ACCESS_FINE_LOCATION)
+    if (fineStatus == PermissionStatus.GRANTED) {
+      return fineStatus.unionValue
+    }
+
+    val coarseStatus = getPermission(Manifest.permission.ACCESS_COARSE_LOCATION)
+    return coarseStatus.unionValue
+  }
+
+  private fun requestPermission(permission: String, promise: Promise) {
+    val activity = reactApplicationContext.currentActivity
+    if (activity is PermissionAwareActivity) {
+      val currentRequestCode = sharedRequestCode++
+      val listener = PermissionListener { requestCode: Int, _: Array<String>, grantResults: IntArray ->
+        if (requestCode == currentRequestCode) {
+          val permissionStatus = if (grantResults.isNotEmpty()) grantResults[0] else PackageManager.PERMISSION_DENIED
+          val parsed = PermissionStatus.fromPermissionStatus(permissionStatus)
+          promise.resolve(parsed.unionValue)
+          return@PermissionListener true
+        }
+        return@PermissionListener false
+      }
+      activity.requestPermissions(arrayOf(permission), currentRequestCode, listener)
+    } else {
+      promise.reject("NO_ACTIVITY", "No PermissionAwareActivity was found! Make sure the app has launched before calling this function.")
+    }
+  }
+
+  @ReactMethod
+  fun requestCameraPermission(promise: Promise) {
+    requestPermission(Manifest.permission.CAMERA, promise)
+  }
+
+  @ReactMethod
+  fun requestMicrophonePermission(promise: Promise) {
+    requestPermission(Manifest.permission.RECORD_AUDIO, promise)
+  }
+
+  @ReactMethod
+  fun requestLocationPermission(promise: Promise) {
+    requestPermission(Manifest.permission.ACCESS_FINE_LOCATION, promise)
+  }
+}
